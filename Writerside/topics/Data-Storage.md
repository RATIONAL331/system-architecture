# Data Storage
## RDB
* 사람이 사용하기 쉬우며 ACID 특성을 가질 수 있음
* 스키마가 강요되어 불편할 수 있음
* 일반적으로 읽기 성능이 비관계형 DB보다는 느림
### Atomicity
* 한 트랜잭션의 원자적으로 동작함
### Consistency
* 제약 조건을 깨지 않게 함
### Isolation
* 또 다른 트랜잭션이 다른 트랜잭션에 간섭할 수 없음
### Durability
* 이미 이루어진 트랜잭션은 계속 반영되어야 함
## Non-RDB
* 일부 레코드에만 특정 속성을 추가하기 어려운 RDB에 비해 쉬움
* 데이터를 테이블에 저장하지 않음
* 일반적으로 읽기 성능이 빠름
* ACID 특성을 대부분 지원하지 않음
### Key-Value
* 대규모 해시테이블과 비슷
* 카운터, 페이지 캐싱과 같은 단순한 구조에서 사용 가능
* [Redis](https://redis.io/), [Amazon DynamoDB](https://aws.amazon.com/dynamodb/)
### Document
* 각 문서를 여러 속성을 가진 객체로 취급하여 관리
* [Mongo](https://www.mongodb.com/resources/basics/databases/document-databases), [Cassandra](https://cassandra.apache.org/_/index.html)
### Graph
* Document의 확장판이지만 Link를 걸거나 탐색등이 가능
* 이상 거래 탐지 서비스를 위해서 사용할 수 있음
* 또는 추천 엔진 서비스를 위해서 사용할 수 있음
* [Neo4J](https://neo4j.com/), [Amazon Neptune](https://aws.amazon.com/neptune/)

## Database Availability & Scalability & Performance
### Indexing (Performance)
* 기본적으로 풀 스캔을 하지만(선형 시간) 인덱싱을 통해서 로그 시간으로 탐색 시간을 줄일 수 있음
* 인덱스 테이블을 통하여 해당 레코드아 어디에 있는지 빠르게 검색
* 여러 열을 가지는 복합 인덱스도 가능
  * 이 때 모든 조합에 해당하는 인덱스 테이블이 생성됨
* 읽기 성능은 좋아지지만, 쓰기 및 수정 시 추가적인 오버헤드 발생
  * 또한 추가적인 공간 필요
### Replication (Availability)
* 시스템 내결함성을 높여 높은 가용성 확보
* 수많은 쿼리를 보내도 안정적인 대응 가능
### Partitioning (Scalability)
* 하나의 테이블을 분할하여 분산 저장
* 접근 시 병렬적으로 쿼리를 수행
#### Sharding
* 여러 서버에 분산하여 다른 서버에 저장

## CAP Theorem
* 분산 데이터베이스는 일관성, 가용성을 모두 100% 확보할 수 없다는 정리
  * 하나를 포기하는 것(0 or 100)이 아닌 일관성 및 가용성 중 어느 것을 더 중점적으로 해야하는 지 정리
* 아래 세가지 속성 중 하나는 반드시 포기
* CP: Mongo => 프리이머리 노드 중단시 세컨더리 승격 중 잠시 쓰기 작업 불가능
* AP: Cassandra => 각각의 노드는 모두 읽기 및 쓰기가 가능하며 시계 방향으로 복제, 통신이 차단되면 일관성이 꺠짐
* CA: 대부분의 RDB => 기본적으로 분할이 되면 일관성과 가용성을 제공할 수 없음
  * 분할이 된 순간 부터 CA가 아니게 됨
### C (Consistency)
* 모든 읽기 요청이 가장 최신의 정보를 받거나 오류를 받아야 함
  * 네트워크 문제가 없다면 가장 최신의 정보를 받아야 함
  * 모든 클라이언트는 데이터베이스 인스턴스에 상관없이 같은 정보를 받도록 보증
### A (Availability)
* 모든 요청에 대해 오류를 받지 않아야 함
  * 오류를 받지 않지만 그것이 유효한 값이기는 함
  * 가장 최신의 정보인지는 보증을 못함
  * 각각의 클라이언트가 받은 정보는 서로 다른 버전일 수 있음
### P (Partition Tolerance)
* 한 노드가 다른 노드와 통신할 수 없을 때 분할(Partition)이 생겼다고 함
* 시스템 내 분할이 생겼을 때 시스템이 여전히 작동하는 것을 의미함
  * 한 노드가 다른 노드와 통신할 수 없을 때, 다른 복제 노드가 사용자 요청에 응답할 수 있어야 함

## Unstructured Data
* 비정형화된 데이터는 스키마를 따르지 않음
* 이미지, 비디오, HTML과 같은 Blob
  * Blob을 그대로 데이터베이스에 저장하기 어려움

### DFS
* 네트워크상에서 상호 연결된 파일 시스템
* 특별한 API가 필요 없고 빠른 속도로 작업할 수 있음
* 파일 수에 제한이 있으며, 웹 API로 파일을 쉽게 접근할 수 없음
### Object Store
* 파일 수에 제한이 없으며, 매우 큰 용량의 데이터도 저장 가능
* 웹 API를 쉽게 제공
* 객체 버저닝 사용 가능
* DFS와 다르게 디렉토리 구조로 관리하지 않고, 버킷으로 관리
* DFS에서는 파일을 언제든지 열어 수정할 수 있지만, OBS는 수정이 불가능하며 언제나 교체해야 함
  * 로그파일과 같이 실시간으로 추가하는 파일은 적합하지 않음
* 성능은 DFS에 비해 떨어짐
* [S3](https://aws.amazon.com/s3/)